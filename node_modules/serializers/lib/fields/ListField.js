import { empty, isEmpty } from 'immuton';
import ValidationException from '../errors/ValidationException.js';
import isValidationError from '../errors/isValidationError.js';
import serializeValidationError from '../errors/serializeValidationError.js';
export default class ListField {
    field;
    type;
    constructor(field) {
        this.field = field;
        this.type = field.type === 'jsonb' ? 'jsonb' : `${field.type}[]`;
    }
    validate(items) {
        return this.mapWith(items, (item) => this.field.validate(item));
    }
    serialize(items) {
        return this.mapWith(items, (item) => this.field.serialize(item));
    }
    deserialize(items) {
        if (items && Array.isArray(items)) {
            return this.mapWith(items, (item) => this.field.deserialize(item));
        }
        throw new ValidationException('invalidArray', `Value is not an array`);
    }
    encode(value) {
        return this.mapWith(value, (item) => encodeURIComponent(this.field.encode(item))).join('&');
    }
    decode(value) {
        // TODO: Should differentiate an empty array vs. an array with a blank value!
        const items = value ? value.split('&') : [];
        return this.mapWith(items, (item) => this.field.decode(decodeURIComponent(item)));
    }
    mapWith(items, iteratee) {
        // NOTE: Even though this only supports arrays, let it also accept an empty OBJECT
        // and consider it as an empty array! This is to work around an issue in postgres-node
        // that may return an empty object instead of an empty array.
        const array = isEmpty(items) ? empty : items;
        const errors = [];
        const results = array.map((item, key) => {
            try {
                return iteratee(item, key);
            }
            catch (error) {
                // Collect nested validation errors
                if (isValidationError(error)) {
                    errors.push({ ...serializeValidationError(error), key });
                    return undefined;
                }
                // Pass through the error
                throw error;
            }
        });
        if (errors.length) {
            throw new ValidationException('invalidItems', `Invalid list items`, errors);
        }
        return results;
    }
}
