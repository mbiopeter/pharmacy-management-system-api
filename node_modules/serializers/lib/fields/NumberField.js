/* eslint-disable no-bitwise */
import ValidationException from '../errors/ValidationException.js';
import parseNumber from '../utils/parseNumber.js';
const { POSITIVE_INFINITY, NEGATIVE_INFINITY } = Number;
function ensureNumber(value) {
    if (typeof value !== 'number' || Number.isNaN(value)) {
        throw new ValidationException('invalidNumber', 'Invalid number value');
    }
    return value;
}
export default class NumberField {
    min;
    max;
    type = 'double precision';
    constructor(options) {
        this.min = options?.min ?? NEGATIVE_INFINITY;
        this.max = options?.max ?? POSITIVE_INFINITY;
    }
    validate(value) {
        return this.validateNumber(ensureNumber(value));
    }
    serialize(value) {
        return this.validateNumber(ensureNumber(value));
    }
    deserialize(value) {
        const number = parseNumber(value);
        if (number == null) {
            throw new ValidationException('invalidNumeric', 'Invalid numeric value');
        }
        return this.validateNumber(ensureNumber(number));
    }
    encode(value) {
        return this.validateNumber(ensureNumber(value)).toString();
    }
    decode(value) {
        return this.deserialize(value);
    }
    validateNumber(value) {
        if (Number.isNaN(value)) {
            throw new ValidationException('invalidNumber', 'Invalid number value');
        }
        if (!Number.isFinite(value)) {
            throw new ValidationException('invalidInfinite', 'Number value cannot be infinite');
        }
        const { min, max } = this;
        if (value < min) {
            throw new ValidationException('lessThanMin', `Value cannot be less than ${min}`);
        }
        if (value > max) {
            throw new ValidationException('moreThanMax', `Value cannot be greater than ${max}`);
        }
        return value;
    }
}
