import { hasOwnProperty, keys } from 'immuton';
import ValidationException from '../errors/ValidationException.js';
import isValidationError from '../errors/isValidationError.js';
import serializeValidationError from '../errors/serializeValidationError.js';
import decodeObject from '../utils/decodeObject.js';
import encodeObject from '../utils/encodeObject.js';
class BaseSerializer {
    type = 'jsonb';
    serialize(input) {
        return this.transformWith(input, (field, value) => field.serialize(value));
    }
    encodeFields(input) {
        return this.transformWith(input, (field, value) => field.encode(value));
    }
    validate(input) {
        return this.transformWith(input, (field, value) => field.validate(value));
    }
    deserialize(input) {
        return this.transformWith(input, (field, value) => field.deserialize(value));
    }
    decodeFields(input) {
        return this.transformWith(input, (field, value) => field.decode(value));
    }
    encode(value) {
        const encodedFields = this.encodeFields(value);
        return encodeObject(encodedFields);
    }
    decode(value) {
        const encodedFields = decodeObject(value);
        return this.decodeFields(encodedFields);
    }
    transformFieldWith(field, value, key, callback) {
        if (typeof value === 'undefined') {
            throw new ValidationException('missingProperty', `Missing required property`);
        }
        return callback(field, value, key);
    }
    transformWith(input, callback) {
        if (typeof input !== 'object' || !input) {
            throw new ValidationException('invalidObject', `Invalid object`);
        }
        const { fields } = this;
        const output = {};
        const errors = [];
        // Deserialize each field
        keys(fields).forEach((key) => {
            const field = fields[key];
            const rawValue = hasOwnProperty(input, key) ? input[key] : undefined;
            try {
                const value = this.transformFieldWith(field, rawValue, key, callback);
                if (typeof value !== 'undefined') {
                    output[key] = value;
                }
            }
            catch (error) {
                // Collect nested validation errors
                if (isValidationError(error)) {
                    errors.push({ ...serializeValidationError(error), key });
                }
                else {
                    // Pass this error through
                    throw error;
                }
            }
        });
        if (errors.length) {
            // Invalid data -> throw validation error that contains nested errors
            throw new ValidationException('invalidProperties', `Invalid fields`, errors);
        }
        return output;
    }
}
export default BaseSerializer;
